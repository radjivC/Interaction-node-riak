// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter2, ProtoCounterBase, Validator, async, inflection, jsonschema, q, under;

  async = require('async');

  inflection = require('inflection');

  jsonschema = require('jsonschema');

  under = require('underscore');

  q = require('q');

  Validator = require('jsonschema').Validator;

  EventEmitter2 = require('eventemitter2').EventEmitter2;

  exports.plugins = require('./plugins').plugins;

  exports.ProtoModel = {
    name: 'ProtoModel',
    bucket: 'undefined',
    connection: null,
    contentType: 'application/json',
    hooks: {
      pre: {
        create: [],
        put: [],
        del: []
      },
      post: {
        create: [],
        put: [],
        del: []
      }
    },
    schema: {},
    registry: {},
    indexes: function() {},
    create: function(key, doc) {
      var inst, self, validation, _ref;
      if (typeof key === 'object') {
        doc = key;
        key = doc.key || null;
        delete doc.key;
      } else if (!key && !doc) {
        doc = {};
      }
      self = this;
      inst = under.extend({}, self, {
        key: key,
        doc: doc,
        links: [],
        reply: {}
      });
      inst.setDefaults(inst, inst.schema, inst.doc);
      under.map(inst.hooks.pre.create, function(hook) {
        return hook(inst);
      });
      validation = self.validator.validate(inst.doc, self.schema);
      if (validation != null ? (_ref = validation.errors) != null ? _ref.length : void 0 : void 0) {
        inst.invalid = validation;
        inst.doc = {};
      } else {
        inst.invalid = false;
        under.map(inst.hooks.post.create, function(hook) {
          return hook(inst);
        });
        self.emit('create', inst);
      }
      return inst;
    },
    keys: function(callback) {
      return this.connection.getKeys({
        bucket: this.bucket
      }, callback);
    },
    get: function(key, options, callback) {
      var deferred, request, self;
      if (typeof key === 'object') {
        options = key;
        key = options.key;
      }
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      self = this;
      deferred = q.defer();
      if (!self.connection) {
        deferred.reject({
          message: 'Not connected'
        });
        return deferred.promise.nodeify(callback);
      }
      if (typeof options === 'function') {
        callback = options;
      } else if (!options) {
        options = {};
      }
      request = {
        bucket: self.bucket,
        key: key
      };
      under.defaults(request, options, self.defaultGetOptions);
      self.connection.get(request, function(reply) {
        var obj, objects;
        if (reply != null ? reply.errmsg : void 0) {
          return deferred.reject({
            message: reply.errmsg
          });
        } else if (reply != null ? reply.content : void 0) {
          objects = under.map(reply.content, function(result) {
            var content, inst;
            if (result.deleted != null) {
              return null;
            }
            if (!options.head) {
              content = self.decode(result.value);
            } else {
              content = {};
            }
            inst = self.create(key, content);
            return under.extend(inst, {
              links: result.links,
              reply: reply,
              key: key
            });
          });
          objects = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = objects.length; _i < _len; _i++) {
              obj = objects[_i];
              if (obj !== null) {
                _results.push(obj);
              }
            }
            return _results;
          })();
          if (!objects.length) {
            return deferred.resolve(null);
          }
          if (objects.length === 1) {
            objects = objects[0];
          }
          if (options.walk && (objects.links != null)) {
            return objects.walk(options.walk).then(function(docs) {
              return deferred.resolve([objects].concat(docs));
            });
          } else {
            return deferred.resolve(objects);
          }
        } else {
          return deferred.resolve(null);
        }
      });
      return deferred.promise.nodeify(callback);
    },
    del: function(options, callback) {
      var deferred, key, run, self;
      self = this;
      deferred = q.defer();
      if (!self.connection) {
        deferred.reject({
          message: 'Not connected'
        });
        return deferred.promise.nodeify(callback);
      }
      if (typeof options === 'function') {
        callback = options;
      } else if (!options) {
        options = {};
      }
      key = options.key || self.key;
      if (!key) {
        deferred.reject({
          message: 'No key'
        });
        return deferred.promise.nodeify(callback);
      }
      run = function(hook, cb) {
        return hook(self, function(err) {
          return cb(err, self);
        });
      };
      async.each(self.getHooks('pre', 'del'), run, function(err, results) {
        var request;
        if (err) {
          return deferred.reject({
            message: err
          });
        } else {
          request = {
            bucket: self.bucket,
            key: key,
            vclock: self.vclock
          };
          under.defaults(request, options, self.defaultDelOptions);
          return self.connection.del(request, function(reply) {
            if (reply.errmsg) {
              return deferred.reject({
                message: reply.errmsg
              });
            } else {
              self.deleted = true;
              self.reply = reply;
              return async.each(self.getHooks('post', 'del'), run, function(err) {
                if (err) {
                  return deferred.reject({
                    message: err
                  });
                } else {
                  self.emit('del', self);
                  return deferred.resolve(null);
                }
              });
            }
          });
        }
      });
      return deferred.promise.nodeify(callback);
    },
    rename: function(target, callback) {
      var deferred, self;
      self = this;
      deferred = q.defer();
      if (!self.connection) {
        deferred.reject({
          message: 'Not connected'
        });
        return deferred.promise.nodeify(callback);
      }
      self.get(target, function(err, existing) {
        var source;
        if (err) {
          return deferred.reject(err);
        } else if (existing) {
          return deferred.reject('target exists');
        } else {
          source = self.key;
          self.key = target;
          return self.put(function(err, obj) {
            if (err) {
              self.key = source;
              return deferred.reject('could not put target key');
            } else {
              return self.del({
                key: source
              }, function(err) {
                var msg;
                if (err) {
                  self.key = source;
                  msg = 'could not delete source key; both keys now exist';
                  return deferred.reject(msg);
                } else {
                  return deferred.resolve(self);
                }
              });
            }
          });
        }
      });
      return deferred.promise.nodeify(callback);
    },
    purge: function(options, callback) {
      var deferred, self;
      self = this;
      deferred = q.defer();
      if (!self.connection) {
        deferred.reject({
          message: 'Not connected'
        });
        return deferred.promise.nodeify(callback);
      }
      if (typeof options === 'function') {
        callback = options;
      } else if (!options) {
        options = {};
      }
      self.keys(function(reply) {
        var run;
        run = function(key, cb) {
          return self.del({
            key: key
          }, function(err) {
            return cb(err);
          });
        };
        return async.each(reply.keys || [], run, function(err, results) {
          if (err) {
            return deferred.reject(err);
          } else {
            return deferred.resolve(results);
          }
        });
      });
      return deferred.promise.nodeify(callback);
    },
    put: function(options, callback) {
      var deferred, run, self, validation, _ref;
      self = this;
      deferred = q.defer();
      if (!self.connection) {
        deferred.reject({
          message: 'Not connected'
        });
        return deferred.promise.nodeify(callback);
      }
      if (typeof options === 'function') {
        callback = options;
      } else if (!options) {
        options = {};
      }
      validation = jsonschema.validate(self.doc, self.schema);
      if (validation != null ? (_ref = validation.errors) != null ? _ref.length : void 0 : void 0) {
        self.invalid = validation;
        deferred.reject({
          message: 'Invalid'
        });
        return deferred.promise.nodeify(callback);
      }
      run = function(hook, cb) {
        return hook(self, function(err) {
          return cb(err, self);
        });
      };
      async.each(self.getHooks('pre', 'put'), run, function(err, results) {
        var request, _ref1;
        if (err) {
          return deferred.reject({
            message: err
          });
        }
        request = {
          bucket: self.bucket,
          content: {
            value: self.encode(self.doc),
            content_type: self.contentType,
            indexes: self.indexes() || [],
            links: self.links
          }
        };
        under.defaults(request, options, self.defaultPutOptions);
        if (self.key != null) {
          request.key = self.key;
        }
        if (((_ref1 = self.reply) != null ? _ref1.vclock : void 0) != null) {
          request.vclock = self.reply.vclock;
        }
        return self.connection.put(request, function(reply) {
          if (reply.errmsg) {
            return deferred.reject({
              message: reply.errmsg
            });
          }
          if (reply.key) {
            self.key = reply.key;
          }
          self.reply = reply;
          return async.each(self.getHooks('post', 'put'), run, function(err, results) {
            if (err) {
              self.invalid = err;
              return deferred.reject({
                message: err
              });
            } else {
              self.invalid = false;
              self.emit('put', self);
              return deferred.resolve(self);
            }
          });
        });
      });
      return deferred.promise.nodeify(callback);
    },
    walk: function(options, callback) {
      var bucket, deferred, get, links, lnk, query, request, self, tag;
      tag = bucket = '*';
      switch (typeof options) {
        case 'string':
          tag = options;
          break;
        case 'object':
          if (options.tag) {
            tag = options.tag;
          }
          if (options.bucket) {
            bucket = options.bucket;
          }
          break;
        case 'function':
          callback = tag;
      }
      self = this;
      deferred = q.defer();
      get = function(v) {
        return [
          {
            bucket: v.bucket,
            data: Riak.mapValuesJson(v),
            key: v.key
          }
        ];
      };
      if (tag === '*') {
        links = self.links;
      } else {
        links = under.filter(self.links, function(lnk) {
          return lnk.tag === tag;
        });
      }
      if (bucket && bucket !== '*') {
        links = under.filter(links, function(lnk) {
          return lnk.bucket === bucket;
        });
      }
      if (!links.length) {
        deferred.resolve([]);
        return deferred.promise.nodeify(callback);
      }
      request = {
        inputs: (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = links.length; _i < _len; _i++) {
            lnk = links[_i];
            _results.push([lnk.bucket, lnk.key]);
          }
          return _results;
        })(),
        query: [
          {
            map: {
              language: 'javascript',
              source: get.toString()
            }
          }
        ]
      };
      query = {
        request: JSON.stringify(request),
        content_type: self.contentType
      };
      self.connection.mapred(query, function(docs) {
        var objects;
        docs = docs || {};
        objects = under.map(docs[0], function(doc) {
          var model;
          model = self.registry[doc.bucket];
          if (model) {
            return model.create(doc.key, doc.data[0]);
          }
        });
        if (under.every(objects, (function(v) {
          return !!v;
        }))) {
          return deferred.resolve(objects);
        } else {
          return deferred.reject({
            message: 'Unable to resolve one or more models'
          });
        }
      });
      return deferred.promise.nodeify(callback);
    },
    link: function(tag, obj, update) {
      var links, updates;
      if (update == null) {
        update = false;
      }
      if ((obj == null) || typeof obj === 'string') {
        links = under.filter(this.links, function(lnk) {
          return lnk.tag === tag && (obj ? lnk.bucket === obj : true);
        });
        if (links && links.length === 1) {
          links = links[0];
        }
        return links;
      } else {
        if (update) {
          updates = under.filter(this.links, function(link) {
            return link.tag === tag && link.bucket === obj.bucket;
          });
          if (updates.length) {
            under.each(updates, function(link) {
              return link.key = obj.key;
            });
          }
        } else {
          this.links.push({
            tag: tag,
            key: obj.key,
            bucket: obj.bucket
          });
        }
        return this.links;
      }
    },
    toJSON: function() {
      return this.doc;
    },
    decode: function(v) {
      return JSON.parse(v);
    },
    encode: function(v) {
      return JSON.stringify(v);
    },
    plugin: function(plugin, options) {
      plugin(this, options);
      return this;
    },
    pre: function(kwd, callable) {
      if (!this.hooks.pre[kwd]) {
        throw new Error("Model does not support pre " + kwd);
      }
      return this.hooks.pre[kwd].push(callable);
    },
    post: function(kwd, callable) {
      if (!this.hooks.post[kwd]) {
        throw new Error("Model does not support post " + kwd);
      }
      return this.hooks.post[kwd].push(callable);
    },
    model: function(name) {
      var bucket, model, _ref;
      _ref = this.registry;
      for (bucket in _ref) {
        model = _ref[bucket];
        if (name === bucket || name === model.name) {
          return model;
        }
      }
    },
    defaultPutOptions: {
      vclock: null,
      w: 'default',
      dw: 'default',
      return_body: false,
      pw: 'default',
      if_not_modified: false,
      if_none_match: false,
      return_head: false
    },
    defaultGetOptions: {
      r: 'default',
      pr: 'default',
      basic_quorum: false,
      notfound_ok: false,
      if_modified: null,
      head: false,
      deletedvclock: true
    },
    defaultDelOptions: {
      rw: 'default',
      vclock: null,
      r: 'default',
      w: 'default',
      pr: 'default',
      pw: 'default',
      pd: 'default'
    },
    getHooks: function(type, kwd) {
      var hooks;
      hooks = this.hooks[type][kwd];
      if (!hooks.length) {
        return [
          function(o, n) {
            return n();
          }
        ];
      } else {
        return hooks;
      }
    },
    setDefaults: function(object, schema, doc) {
      return under.each(schema.properties, function(prop, name) {
        var def;
        if (doc[name] == null) {
          def = prop["default"];
          if (def !== void 0) {
            if (typeof def === 'function') {
              def = def();
            }
            if (def !== void 0) {
              def = JSON.parse(JSON.stringify(def));
            }
          } else {
            if (prop.type === 'object') {
              def = {};
            }
          }
          doc[name] = def;
          if (prop.properties) {
            return object.setDefaults(object, prop, doc[name]);
          }
        }
      });
    },
    indexSearch: function(query, callback) {
      var deferred, self;
      self = this;
      deferred = q.defer();
      under.defaults(query, {
        bucket: self.bucket,
        qtype: 0
      });
      self.connection.getIndex(query, function(reply) {
        if ((reply != null ? reply.keys : void 0) != null) {
          return deferred.resolve(reply.keys);
        } else {
          return deferred.reject(null);
        }
      });
      return deferred.promise.nodeify(callback);
    }
  };

  exports.createModel = function(name, defn) {
    var base, server;
    if (typeof name === 'object') {
      defn = name;
      name = defn.name;
    } else if (!defn) {
      defn = {};
    }
    if (!name) {
      throw new TypeError('Model name required');
    }
    if (!defn.bucket) {
      defn.bucket = inflection.pluralize(name.toLowerCase());
    }
    base = {
      hooks: {
        pre: {
          create: [],
          put: [],
          del: []
        },
        post: {
          create: [],
          put: [],
          del: []
        }
      },
      schema: defn.schema || {},
      validator: new Validator
    };
    server = new EventEmitter2(defn.events);
    delete defn.events;
    return exports.ProtoModel.registry[defn.bucket] = under.extend(server, exports.ProtoModel, base, defn);
  };

  ProtoCounterBase = {
    name: 'ProtoCounter',
    contentType: void 0,
    defaultPutOptions: {
      w: 'default',
      dw: 'default',
      returnvalue: false,
      pw: 'default'
    },
    defaultGetOptions: {
      r: 'default',
      pr: 'default',
      basic_quorum: false,
      notfound_ok: false
    },
    defaultDelOptions: {
      rw: 'default',
      r: 'default',
      w: 'default',
      pr: 'default',
      pw: 'default',
      pd: 'default'
    },
    get: function(key, options, callback) {
      var deferred, request, self;
      if (typeof key === 'object') {
        options = key;
        key = options.key;
      }
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      self = this;
      deferred = q.defer();
      if (!self.connection) {
        deferred.reject({
          message: 'Not connected'
        });
        return deferred.promise.nodeify(callback);
      }
      if (typeof options === 'function') {
        callback = options;
      } else if (!options) {
        options = {};
      }
      request = {
        bucket: self.bucket,
        key: key
      };
      under.defaults(request, options, self.defaultGetOptions);
      self.connection.getCounter(request, function(reply) {
        var inst;
        if (reply != null ? reply.errmsg : void 0) {
          return deferred.reject({
            message: reply.errmsg
          });
        } else if (reply != null ? reply.value : void 0) {
          inst = self.create(key, {
            value: reply.value
          });
          return deferred.resolve(inst);
        } else {
          return deferred.resolve(null);
        }
      });
      return deferred.promise.nodeify(callback);
    },
    put: function(options, callback) {
      var deferred, run, self, validation, _ref;
      self = this;
      deferred = q.defer();
      if (!self.connection) {
        deferred.reject({
          message: 'Not connected'
        });
        return deferred.promise.nodeify(callback);
      }
      if (typeof options === 'function') {
        callback = options;
      } else if (!options) {
        options = {};
      }
      validation = jsonschema.validate(self.doc, self.schema);
      if (validation != null ? (_ref = validation.errors) != null ? _ref.length : void 0 : void 0) {
        self.invalid = validation;
        deferred.reject({
          message: 'Invalid'
        });
        return deferred.promise.nodeify(callback);
      }
      run = function(hook, cb) {
        return hook(self, function(err) {
          return cb(err, self);
        });
      };
      async.each(self.getHooks('pre', 'put'), run, function(err, results) {
        var request;
        if (err) {
          return deferred.reject({
            message: err
          });
        }
        request = {
          bucket: self.bucket,
          amount: self.doc.value,
          key: self.key
        };
        under.defaults(request, options, self.defaultPutOptions);
        return self.connection.updateCounter(request, function(reply) {
          if (reply.errmsg) {
            return deferred.reject({
              message: reply.errmsg
            });
          }
          self.reply = reply;
          return async.each(self.getHooks('post', 'put'), run, function(err, results) {
            if (err) {
              self.invalid = err;
              return deferred.reject({
                message: err
              });
            } else {
              self.invalid = false;
              self.emit('put', self);
              return deferred.resolve(self);
            }
          });
        });
      });
      return deferred.promise.nodeify(callback);
    },
    del: function(options, callback) {
      var deferred, key, run, self;
      self = this;
      deferred = q.defer();
      if (!self.connection) {
        deferred.reject({
          message: 'Not connected'
        });
        return deferred.promise.nodeify(callback);
      }
      if (typeof options === 'function') {
        callback = options;
      } else if (!options) {
        options = {};
      }
      key = self.key || options.key;
      if (!key) {
        deferred.reject({
          message: 'No key'
        });
        return deferred.promise.nodeify(callback);
      }
      run = function(hook, cb) {
        return hook(self, function(err) {
          return cb(err, self);
        });
      };
      async.each(self.getHooks('pre', 'del'), run, function(err, results) {
        var request;
        if (err) {
          return deferred.reject({
            message: err
          });
        } else {
          request = {
            bucket: self.bucket,
            key: key
          };
          under.defaults(request, options, self.defaultDelOptions);
          return self.connection.del(request, function(reply) {
            if (reply.errmsg) {
              return deferred.reject({
                message: reply.errmsg
              });
            } else {
              self.deleted = true;
              self.reply = reply;
              return async.each(self.getHooks('post', 'del'), run, function(err) {
                if (err) {
                  return deferred.reject({
                    message: err
                  });
                } else {
                  self.emit('del', self);
                  return deferred.resolve(null);
                }
              });
            }
          });
        }
      });
      return deferred.promise.nodeify(callback);
    }
  };

  exports.ProtoCounter = under.extend({}, exports.ProtoModel, ProtoCounterBase);

  exports.createCounterModel = function(name, defn) {
    var base, server;
    if (typeof name === 'object') {
      defn = name;
      name = defn.name;
    } else if (!defn) {
      defn = {};
    }
    if (!name) {
      throw new TypeError('Model name required');
    }
    if (!defn.bucket) {
      defn.bucket = inflection.pluralize(name.toLowerCase());
    }
    if (!defn.schema) {
      defn.schema = {
        additionalProperties: false,
        properties: {
          value: {
            type: 'number'
          }
        }
      };
    }
    base = {
      hooks: {
        pre: {
          create: [],
          put: [],
          del: []
        },
        post: {
          create: [],
          put: [],
          del: []
        }
      },
      schema: defn.schema || {},
      validator: new Validator
    };
    server = new EventEmitter2(defn.events);
    delete defn.events;
    return exports.ProtoCounter.registry[defn.bucket] = under.extend(server, exports.ProtoCounter, base, defn);
  };

}).call(this);
